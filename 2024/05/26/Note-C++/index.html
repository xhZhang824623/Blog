<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="C++基础特性：变量及基本类型: 初始化和赋值的区别:初始化和赋值并不是一回事,初始化是对象定义后为其赋予一个初始值,但是赋值设计的操作是将变量原油的值抹去,并为其赋予新值 列表初始化,下边的几种初始化类型都满足要求,但是{}相关的两种初始化类型称为列表初始化,能够防止因为强制类型转换时导致的信息丢失  1234int a &#x3D; 0;int a &#x3D; &#123;0&#125;;int a&#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++基础知识">
<meta property="og:url" content="http://example.com/2024/05/26/Note-C++/index.html">
<meta property="og:site_name" content="XhZhang&#39;s Blogs">
<meta property="og:description" content="C++基础特性：变量及基本类型: 初始化和赋值的区别:初始化和赋值并不是一回事,初始化是对象定义后为其赋予一个初始值,但是赋值设计的操作是将变量原油的值抹去,并为其赋予新值 列表初始化,下边的几种初始化类型都满足要求,但是{}相关的两种初始化类型称为列表初始化,能够防止因为强制类型转换时导致的信息丢失  1234int a &#x3D; 0;int a &#x3D; &#123;0&#125;;int a&#123;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d94761ca4b0b4976a080931159c127ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6ff5df7fd4244cc7b6720ceae90f9eec.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_16.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_12.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_14.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_10.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_8.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_6.png">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_2.png">
<meta property="article:published_time" content="2024-05-26T08:38:09.325Z">
<meta property="article:modified_time" content="2024-05-26T08:55:42.266Z">
<meta property="article:author" content="XhZhang">
<meta property="article:tag" content="Coding">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/d94761ca4b0b4976a080931159c127ea.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C/C++基础知识</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/05/26/Note-WirelessComm/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/05/26/Note-OpenCv/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/05/26/Note-C++/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/05/26/Note-C++/&text=C/C++基础知识"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/05/26/Note-C++/&is_video=false&description=C/C++基础知识"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C/C++基础知识&body=Check out this article: http://example.com/2024/05/26/Note-C++/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/05/26/Note-C++/&name=C/C++基础知识&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/05/26/Note-C++/&t=C/C++基础知识"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">C++基础特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">变量及基本类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">指针和引用的区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">函数指针&#x2F;指针函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数指针：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">指针函数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88-%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">野指针&#x2F;悬空指针：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">const限定符：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cosnt%E5%92%8Cconsexpr"><span class="toc-number">1.5.</span> <span class="toc-text">cosnt和consexpr:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E7%9A%84%E8%AF%AD%E4%B9%89%E4%BA%8C%E4%B9%89%E6%80%A7%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">const的语义二义性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">define和const的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%92%8Ctypedef%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">define和typedef的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">this指针：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%92%8CC-%E5%AF%B9%E4%BA%8Estruct%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">C和C++对于struct的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct%E5%92%8Cunion%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">struct和union：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.12.</span> <span class="toc-text">typedef关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-malloc-calloc%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.13.</span> <span class="toc-text">new&#x2F;malloc&#x2F;calloc的区别和联系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.</span> <span class="toc-text">new和malloc的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%92%8Ccalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.2.</span> <span class="toc-text">malloc和calloc的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size-t%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">size_t：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%EF%BC%9A"><span class="toc-number">1.15.</span> <span class="toc-text">内联函数inline：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%EF%BC%9A"><span class="toc-number">1.16.</span> <span class="toc-text">volatile：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-C%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">1.17.</span> <span class="toc-text">extern C关键字：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="toc-number">1.18.</span> <span class="toc-text">strcpy的缺陷：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.19.</span> <span class="toc-text">自由存储区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%EF%BC%9A"><span class="toc-number">1.20.</span> <span class="toc-text">左值&#x2F;右值：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%EF%BC%9A-1"><span class="toc-number">1.20.1.</span> <span class="toc-text">左值&#x2F;右值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.20.2.</span> <span class="toc-text">左值引用&#x2F;右值引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.20.3.</span> <span class="toc-text">左值引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.21.</span> <span class="toc-text">右值引用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%9A"><span class="toc-number">1.22.1.</span> <span class="toc-text">移动构造和拷贝构造：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.23.</span> <span class="toc-text">move函数的实现原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.24.</span> <span class="toc-text">智能指针：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.24.1.</span> <span class="toc-text">智能指针的三个重要函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr%E6%AF%94unique-ptr%E5%B7%AE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9A"><span class="toc-number">1.24.2.</span> <span class="toc-text">auto_ptr比unique_ptr差的地方：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.24.3.</span> <span class="toc-text">unique_ptr:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#share-ptr%EF%BC%9A"><span class="toc-number">1.24.4.</span> <span class="toc-text">share_ptr：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.24.5.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-number">1.25.</span> <span class="toc-text">值传递、引用传递、指针传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.1.</span> <span class="toc-text">值传递：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.2.</span> <span class="toc-text">引用传递：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.3.</span> <span class="toc-text">指针传递：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.26.</span> <span class="toc-text">结构体相等的判断方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.</span> <span class="toc-text">强制类型转换：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.1.</span> <span class="toc-text">C语言中的强制类型转换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.2.</span> <span class="toc-text">C++中的强制类型转换：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-cast%EF%BC%9A"><span class="toc-number">1.27.2.1.</span> <span class="toc-text">static_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-cast%EF%BC%9A"><span class="toc-number">1.27.2.2.</span> <span class="toc-text">dynamic_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-cast%EF%BC%9A"><span class="toc-number">1.27.2.3.</span> <span class="toc-text">const_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reinterpret-cast%EF%BC%9A"><span class="toc-number">1.27.2.4.</span> <span class="toc-text">reinterpret_cast：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.28.</span> <span class="toc-text">一些高级概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A8%A1%E7%89%88%EF%BC%89%EF%BC%9A"><span class="toc-number">1.28.1.</span> <span class="toc-text">泛型编程（模版）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.1.</span> <span class="toc-text">函数模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.2.</span> <span class="toc-text">类模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.3.</span> <span class="toc-text">变量模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.1.4.</span> <span class="toc-text">函数重载和函数模版的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%92%8C%E7%B1%BB%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.1.5.</span> <span class="toc-text">函数模版和类模版的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%EF%BC%9A"><span class="toc-number">1.28.2.</span> <span class="toc-text">STL：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E7%9A%846%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.28.2.1.</span> <span class="toc-text">STL的6大组件：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.28.2.1.1.</span> <span class="toc-text">容器:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E8%A6%81%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">1.28.2.1.1.1.</span> <span class="toc-text">容器的概要及使用原则：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.28.2.1.2.</span> <span class="toc-text">迭代器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.28.2.1.3.</span> <span class="toc-text">算法:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.28.2.1.4.</span> <span class="toc-text">仿函数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.28.2.1.5.</span> <span class="toc-text">适配器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E4%BB%B6"><span class="toc-number">1.28.2.1.6.</span> <span class="toc-text">空间配置器件:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="toc-number">1.28.2.2.</span> <span class="toc-text">STL的缺陷：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E4%B8%ADreserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.2.3.</span> <span class="toc-text">vector中reserve和resize的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reserve%EF%BC%9A"><span class="toc-number">1.28.2.3.1.</span> <span class="toc-text">Reserve：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Resieze%EF%BC%9A"><span class="toc-number">1.28.2.3.2.</span> <span class="toc-text">Resieze：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96%EF%BC%9A"><span class="toc-number">1.28.2.4.</span> <span class="toc-text">模版特化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%EF%BC%9A"><span class="toc-number">1.28.2.5.</span> <span class="toc-text">类型萃取：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.29.</span> <span class="toc-text">C++ 11的新特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A"><span class="toc-number">1.29.1.</span> <span class="toc-text">auto类型推导：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A"><span class="toc-number">1.29.2.</span> <span class="toc-text">decltype类型推导：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.29.3.</span> <span class="toc-text">lambda表达式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.29.4.</span> <span class="toc-text">for语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.29.5.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0"><span class="toc-number">1.29.6.</span> <span class="toc-text">move函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.29.7.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E7%A6%81%E6%AD%A2%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.29.8.</span> <span class="toc-text">使用&#x2F;禁止对象的默认构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">1.29.9.</span> <span class="toc-text">constexpr:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%EF%BC%9A"><span class="toc-number">1.29.10.</span> <span class="toc-text">nullptr：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9A"><span class="toc-number">1.29.11.</span> <span class="toc-text">可扩展的随机数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%8F%90%E4%BE%9B%E4%BA%86%E7%94%9F%E6%88%90%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8C%85%E5%90%AB2%E9%83%A8%E4%BB%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E5%B8%83%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9A%84%E5%88%B0%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%85%88%E5%AE%9A%E4%B9%89%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E%EF%BC%8C%E5%B9%B6%E5%88%B6%E5%AE%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-number">1.30.</span> <span class="toc-text">C++11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎+随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布1234std::uniform_int_distribution&lt;int&gt; distribution(0, 99); &#x2F;&#x2F; 离散型均匀分布std::mt19937 engine; &#x2F;&#x2F; 随机数生成引擎auto generator &#x3D; std::bind(distribution, engine); &#x2F;&#x2F; 将随机数生成引擎和分布绑定生成函数int random &#x3D; generator();  &#x2F;&#x2F; 产生随机数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">C++的面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象的三大特征：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99-%E9%9A%90%E8%97%8F%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">函数的重载&#x2F;重写&#x2F;隐藏：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">多态的总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">虚函数和纯虚函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">虚继承：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">深拷贝&#x2F;浅拷贝：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">2.7.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.7.1.</span> <span class="toc-text">友元函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">2.7.2.</span> <span class="toc-text">友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.8.</span> <span class="toc-text">如何让一个类不能被继承：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-number">2.9.</span> <span class="toc-text">如何让类对象不能拷贝：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">2.10.</span> <span class="toc-text">如何让一个类不能实例化：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">2.11.</span> <span class="toc-text">拷贝构造为何必须声明为引用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.12.</span> <span class="toc-text">实例化一个类对象的步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">2.13.</span> <span class="toc-text">C++类对象的初始化顺序：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.14.</span> <span class="toc-text">如何禁止构造函数被使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.15.</span> <span class="toc-text">使用列表初始化快的原因：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9A"><span class="toc-number">2.16.</span> <span class="toc-text">静态绑定&#x2F;动态绑定：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-number">2.17.</span> <span class="toc-text">编译时多态&#x2F;运行时多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">2.17.1.</span> <span class="toc-text">编译时多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">2.17.2.</span> <span class="toc-text">运行时多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.17.3.</span> <span class="toc-text">两者的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="toc-number">2.18.</span> <span class="toc-text">如何让成员函数不可改变成员变量的值：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%A8%E6%A0%88-%E5%A0%86%EF%BC%9A"><span class="toc-number">2.19.</span> <span class="toc-text">限制对象内存在栈&#x2F;堆：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%A8%E6%A0%88%EF%BC%9A"><span class="toc-number">2.19.1.</span> <span class="toc-text">限制类对象的内存在栈：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%A8%E5%A0%86%EF%BC%9A"><span class="toc-number">2.19.2.</span> <span class="toc-text">限制类对象的内存在堆：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">进程间通信的方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">互斥量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">共享互斥量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">信号量:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">条件变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-number">3.2.5.</span> <span class="toc-text">call_once:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">3.2.6.</span> <span class="toc-text">线程操作相关：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.2.7.</span> <span class="toc-text">异步编程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-select"><span class="toc-number">3.2.8.</span> <span class="toc-text">epoll&#x2F;select</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-number">3.3.</span> <span class="toc-text">I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%846%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">设计模式的6大原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E7%B1%BB%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">设计模式三大类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">几种常见的设计模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">工厂模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">简单工厂模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">工厂方法模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">抽象工厂模式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.3.</span> <span class="toc-text">观察者模式：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">日常总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">指针大小：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">解决哈希冲突的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">开放寻址法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">溢出表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%EF%BC%9A"><span class="toc-number">5.2.4.</span> <span class="toc-text">再哈希：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-number">5.3.</span> <span class="toc-text">UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">依赖：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">关联：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B9%E5%85%B3%E8%81%94A-B%EF%BC%9A"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">单项关联A-&gt;B：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94AB"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">双向关联A&lt;-&gt;B:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%BA%AB%E5%85%B3%E8%81%94%EF%BC%9A"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">自身关联：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%EF%BC%9A"><span class="toc-number">5.3.3.</span> <span class="toc-text">聚合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%EF%BC%9A"><span class="toc-number">5.3.4.</span> <span class="toc-text">组合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%EF%BC%9A"><span class="toc-number">5.3.5.</span> <span class="toc-text">泛化：</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        C/C++基础知识
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">XhZhang</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-05-26T08:38:09.325Z" class="dt-published" itemprop="datePublished">2024-05-26</time>
        
        (Updated: <time datetime="2024-05-26T08:55:42.266Z" class="dt-updated" itemprop="dateModified">2024-05-26</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Notes/">Notes</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C-C/" rel="tag">C/C++</a>, <a class="p-category" href="/tags/Coding/" rel="tag">Coding</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="C-基础特性："><a href="#C-基础特性：" class="headerlink" title="C++基础特性："></a>C++基础特性：</h1><h2 id="变量及基本类型"><a href="#变量及基本类型" class="headerlink" title="变量及基本类型:"></a>变量及基本类型:</h2><ul>
<li>初始化和赋值的区别:初始化和赋值并不是一回事,初始化是对象定义后为其赋予一个初始值,但是赋值设计的操作是将变量原油的值抹去,并为其赋予新值</li>
<li>列表初始化,下边的几种初始化类型都满足要求,但是{}相关的两种初始化类型称为列表初始化,能够防止因为强制类型转换时导致的信息丢失</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>建议为内置对象(不是程序员定义的)都赋初值,所有函数外定义的内置类型会自动初始化为0,函数内的内置类型如果无初始化的话,其值为<strong>未定义</strong>的类型</li>
<li>变量声明和定义的关系:<ul>
<li>声明: 让一个变量的名字让其他模块或程序所知,如果想引用其他模块定义的对象,那么必须引用包含该对象声明的文件才行</li>
<li>如果仅想声明一个变量,那么必然不能初始化它,且需要在变量前添加关键字<strong>extern</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;   <span class="comment">//这是声明</span></span><br><span class="line">externa <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//这不是声明,这是定义</span></span><br><span class="line"><span class="comment">/* 且若尝试在函数体内对extern标记的变量进行初始化,会报错 */</span></span><br></pre></td></tr></table></figure></li>
<li>变量只能被定义一次,但是可以被声明多次</li>
<li>如果需要在多个文件中使用某个变量,那必须将某个变量的声明和定义分开,切其他需要使用该变量的地方都需要实现进行声明</li>
</ul>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>引用并非对象，只是一个已存在对象的别名而已，切后续不能重新切换绑定关系，所以引用必须初始化</li>
<li>引用不是对象，所以不能定义引用的引用，只能对对象定义引用</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a>指针和引用的区别：</h4><pre><code>1. 指针是对象；引用是绑定（别名），所以一般情况下指针是占内存空间的，但是引用不占（有些编译器底层用指针实现引用的话，就占）
2. 指针可以不初始化；引用必须初始化
3. 指针所指向的对象可以变化；引用不能更改绑定关系
4. 指针可以有多级，但是引用只能有一级，也就是说可以定义指针的指针，但是不能再定义引用的引用
</code></pre>
<ul>
<li>**int *p &#x3D; val**，可以解释为p存放val的地址，亦可解释为p指向变量val</li>
<li>指针类型需要和所指向的对象类型完全匹配</li>
<li>void*类型是一个特殊的存在：<ul>
<li>void*是一个能指向任意类型的指针</li>
<li>void<em>能做的操作有限：比较、函数如参、返回值，或者赋值给另外一个void</em>的指针</li>
<li>void*指向的对象不能直接访问，说白了，因为对象的类型不定，即只知道初始地址，但是不知道向后去多少</li>
</ul>
</li>
</ul>
<h2 id="函数指针-指针函数："><a href="#函数指针-指针函数：" class="headerlink" title="函数指针&#x2F;指针函数："></a>函数指针&#x2F;指针函数：</h2><h3 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a>函数指针：</h3><p>顾名思义，是一个指针，指向函数在代码段中的起始位置（程序在编译之后，在代码段中都有自己的起始地址和结束地址，函数指针就是指向函数起始地址的指针）</p>
<h3 id="指针函数："><a href="#指针函数：" class="headerlink" title="指针函数："></a>指针函数：</h3><p>顾名思义，是一个函数，返回值是一个指针</p>
<h2 id="野指针-悬空指针："><a href="#野指针-悬空指针：" class="headerlink" title="野指针&#x2F;悬空指针："></a>野指针&#x2F;悬空指针：</h2><ul>
<li>野指针：指向不确定的指针，通常是定义后未初始化的指针；避免方法就是定义时就做初始化</li>
<li>悬空指针：指向确定，但是内存被释放了；释放对应内存后，指针也置空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr_1;     <span class="comment">//野指针</span></span><br><span class="line"><span class="type">int</span> *ptr_2 = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="built_in">free</span>(ptr_2);    <span class="comment">//此时ptr_2已经悬空了</span></span><br><span class="line">p = <span class="literal">nullptr</span>;    <span class="comment">//避免悬空</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>nullptr</code>和<code>NULL</code>的区别：<ul>
<li><code>NULL</code>：是预处理变量，是一个宏定义，等于0</li>
<li><code>nullptr</code>：是关键字，有c++11引入的，是有类型的，可以被转换成为任意一种类型</li>
<li>nullptr的优势：<ul>
<li>有类型</li>
<li>函数重载：如果重载函数的实参为NULL，因为NULL就是0，有可能无法明确区分到底是调用哪个，而nullptr则不会出现这种错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="const限定符："><a href="#const限定符：" class="headerlink" title="const限定符："></a>const限定符：</h2><ul>
<li><p>const是用来修饰常量的，即被const修饰的变量会成为常量，这也意味着必须为const修饰的对象初始化</p>
</li>
<li><p>const修饰的对象默认情况下只在定义的文件内有效，如果需要在多个文件内都生效，则需要重复定义，但是若不想重复定义，也有方法：就在对象定义和声明的地方都加<strong>extern</strong>修饰符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> fileSize = <span class="number">512</span>;    <span class="comment">//tess.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> filezSize;     <span class="comment">//test.h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指向常量的指针和引用，只是它们的自以为是，它们觉得自己指向的是常量，自觉的不去修改对象的值，但是又可能实际指向的对象是非常量，且可以通过其他途径对其值进行修改</p>
</li>
<li><p><strong>常量指针</strong>：是一个指针，用常量来修饰，则说明这个指针是指向常量的，即指向的目标地址内的值不能变，但是指针指向的地方可以变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p;   <span class="comment">//从右至左，首先是一个指针，再加了const修饰</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>指针常量</strong>：是一个常量，用指针来修饰，则说明这个指针是不能变的，某个指针赋值之后就不能变了，即指向的内存地址是固定的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p;   <span class="comment">//从右至左，首先是一个常量，再是一个指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cost成员变量：只能在类的内部进行定义、声明，在构造函数初始化列表中初始化</p>
</li>
<li><p>const成员函数：const的函数不能修改其他成员变量的值（除非嫁加mutable修饰符的成员变量），不能调用其他非const的成员函数</p>
</li>
<li><p>const参数：函数内部不能修改实参的值，一般情况下都是const指针，或引用</p>
</li>
<li><p>const返回值：如果函数的返回值为指针或者引用，那么可以用const修饰，避免发生修改</p>
</li>
<li><p>普通引用不能绑定到常量上，但是常量引用可以绑定到常量上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;i = <span class="number">0</span>;     <span class="comment">//非法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;j = <span class="number">0</span>;   <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;arg)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">2</span>);    <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;arg)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">2</span>);    <span class="comment">//correct</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cosnt和consexpr"><a href="#cosnt和consexpr" class="headerlink" title="cosnt和consexpr:"></a>cosnt和consexpr:</h2><p>常量表达式修饰符<code>constexpr</code>，所谓<code>常量表达式</code>，就是组成该表达式的都是常量，当常量表达式编译后，值就确定了，且不能再改变<br>常量表达式和非常量表达式的计算时机是不同的，<code>常量表达式</code>在<code>编译阶段</code>，而<code>非常量表达式</code>是在<code>运行阶段</code>，那就意味着常量表达式只需要计算一次，能够节省程序运行的时间<br><code>constexpr</code>用于修饰<code>普通变量</code>、<code>函数</code>、<code>构造函数</code></p>
<h3 id="const的语义二义性："><a href="#const的语义二义性：" class="headerlink" title="const的语义二义性："></a>const的语义二义性：</h3><p>所谓const的二义性指的是，const既可以表示<code>只读</code>，又可以表示<code>常量</code>，通过如下的例子可以分别两者的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[a];   <span class="comment">//error，因为这里的const不是常量，只读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> array[a];   <span class="comment">//ok, 这里的a是常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说在C++11中为了区分开const只读、常量的语义，引入了constexpr修饰符，将const的常量语义划分给了const</p>
<h2 id="define和const的区别："><a href="#define和const的区别：" class="headerlink" title="define和const的区别："></a>define和const的区别：</h2><ul>
<li>define是预处理命令；const是编译阶段的修饰符</li>
<li>define是宏定义，在预处理的时候编译器会直接进行代码替换，有多少就替换多少；但const是在编译的时候进行处理的</li>
<li>define就是简单的语句替换，没有类型；const是有类型和对应的类型检查的</li>
<li>define可以接受参数；const不能接受参数</li>
<li>define可以用来防止头文件被多次引入</li>
<li>define不能进行调试，但是const可以</li>
</ul>
<h2 id="define和typedef的区别："><a href="#define和typedef的区别：" class="headerlink" title="define和typedef的区别："></a>define和typedef的区别：</h2><ul>
<li>define是预处理命令，typedef是编译阶段生效的命令，用来定义别名</li>
<li>define没有类型检查，只是简单的语句替换</li>
<li>define没有作用域，在源文件中define的宏可以在文件内部随处使用；在头文件中定义的宏，可以在所有include的其他地方进行替换</li>
<li>处理指针时不一样：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ptr a, b, c;</span><br><span class="line">    PTR d, e, f;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; <span class="built_in">sizeof</span>(e) &lt;&lt; <span class="built_in">sizeof</span>(f) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="comment">// 888</span></span><br><span class="line"><span class="comment">// 811</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>在C语言中，<code>static</code>用于定义：<code>局部静态变量</code>、<code>外部静态变量</code>、<code>静态函数</code><br>在C++中，<code>static</code>用于定义：<code>局部静态变量</code>、<code>外部静态变量</code>、<code>静态函数</code>，因为C++中有类的概念，所以就多了<code>静态成员函数</code>、<code>静态成员变量</code></p>
<p>个人理解：static的作用有2个主要方面：</p>
<ul>
<li>限制作用域</li>
<li>限定变量或函数的生命周期</li>
</ul>
<p>如下是一个常见的静态的东西：</p>
<ul>
<li><code>静态全局变量：</code>静态全局变量和全局变量都存储在<code>静态存储区</code>，所以它们的生命周期和整个程序一致，只能被初始化一次，<strong>But</strong>普通全局变量的作用域是整个程序，也就是别的源文件中的函数也是可以访问的；而静态全局变量的作用域就只是源文件内部，只能被源文件内部的函数使用，</li>
<li><code>静态局部变量：</code>静态局部变量也是存放在静态存储区的，所以生命周期和程序一致，且只能被初始化一次，但是其作用于是函数内部，和正常的函数局部变量的作用域是一样的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">0</span>;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticGlobalVar = <span class="number">0</span>; <span class="comment">//静态全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocalVar = <span class="number">0</span>;  <span class="comment">//静态局部变量</span></span><br><span class="line">    staticGlobalVar = <span class="number">1</span>;    <span class="comment">//error，只能初始化一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>静态函数：</code>静态函数的作用域是源文件内部，不能被其他文件访问</p>
</li>
<li><p><code>静态成员变量</code>：虽然是成员变量，但是其存储位置仍然是静态存储区域，这也就是为何要求警静态成员变量必须是在外部定义&amp;初始化，只在类内部进行声明了，有一些需要注意的点：</p>
<ul>
<li>静态成员变量不能在构造函数内部对齐进行初始化（只有一次，在外部）</li>
<li>类的所有成员（包括派生类）共享静态成员变量，切不能对其值做修改</li>
<li>静态成员变量可以作为成员函数的参数，其他成员变量🙅</li>
<li>静态成员变量的类型可以是所属类的类型，但是其他的成员变量只能是所属类的指针、引用<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> var1</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> var2; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">static</span> A varA;  <span class="comment">//静态成员</span></span><br><span class="line">    A *ptrA;    <span class="comment">//OK</span></span><br><span class="line">    A &amp;refA;    <span class="comment">//OK</span></span><br><span class="line">    A varA1;    <span class="comment">//error，不能这样搞</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> i = var1)</span> &#123;    <span class="comment">//error</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i = var2)</span> &#123;    <span class="comment">//OK</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>静态成员函数</code>：静态成员函数不能访问非静态的成员变量和成员函数，因为静态成员函数没有<code>this</code>指针</p>
</li>
<li><p>静态对象：静态对象的生命周期是整个程序，但是非静态的就是随时可能终结</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class A start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class A stop&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class B start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class B stop&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> ClassA classA;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ClassB classB;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main output&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果 */</span></span><br><span class="line"><span class="comment">// Class A start</span></span><br><span class="line"><span class="comment">// Class B start</span></span><br><span class="line"><span class="comment">// Class B stop</span></span><br><span class="line"><span class="comment">// Main output</span></span><br><span class="line"><span class="comment">// Class A stop</span></span><br></pre></td></tr></table></figure>
<p><strong>为何静态变量只能初始化一次？</strong><br>因为它存放在静态存储区，多个对象共享的，所以如果在别人对这个静态变量正在使用时，有个玩意给重新初始化了，那会影响其他正在使用的对象的</p>
</li>
</ul>
<h2 id="this指针："><a href="#this指针：" class="headerlink" title="this指针："></a>this指针：</h2><p>this指针是指向类对象的首地址的指针，this指针本身的存放不一定，这个要看编译器的实现<br>this指针在编译过程中，编译器自动为类的非静态成员函数隐式加入一个this指针的形参，作用就是在非静态成员函数中访问非静态成员变量；所以静态成员函数和全局函数都没this指针，因此这些静态成员函数只能访问静态成员变量，不能访问非静态成语变量</p>
<h2 id="C和C-对于struct的区别："><a href="#C和C-对于struct的区别：" class="headerlink" title="C和C++对于struct的区别："></a>C和C++对于struct的区别：</h2><p>其实c++中的class完全包含了struct的所有能力，struct只是一个抽象数据类型，把一些变量、函数放在一起而已；所以struct的成员默认都是public的，而class的默认都是private的</p>
<h2 id="struct和union："><a href="#struct和union：" class="headerlink" title="struct和union："></a>struct和union：</h2><p>union的成员共享存储空间（最大成员的整数倍），所以也代表同时只能有一个union的成员是有效的，而struct的成员各有各的内存空间（整体的内存是按照内存空间的策略执行的），union成员必须是定长的，struct内部可以接受变长成员</p>
<h2 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h2><p><strong>typedef</strong>关键字是用以定义一种新关键字的修饰符，通常用于简化一些冗长的类或结构体的声明，用以赋予一个更简单、更容易理解的声明<br>一个很通用的举例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为Student的结构体及两个Student类型的变量stu1、stu2 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; stu1, stu2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用typedef声明创建了新类型STU，后续可以用STU定义新变量 */</span></span><br><span class="line"><span class="comment">/* Student是本名，STU是别名 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; STU;</span><br><span class="line">STU stu1, stu2;</span><br><span class="line"></span><br><span class="line">STU &lt;=&gt; <span class="keyword">struct</span> Student</span><br><span class="line"><span class="comment">/* 后续进行变量定义时，既可以用“struct Student xxx”，也可用”STU xxx“ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更为简化的结构体定义方式 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要注意的是stu1和stu2是变量且可以直接访问，而STU是一个结构体类型且不能直接访问 */</span></span><br></pre></td></tr></table></figure>

<h2 id="new-malloc-calloc的区别和联系"><a href="#new-malloc-calloc的区别和联系" class="headerlink" title="new&#x2F;malloc&#x2F;calloc的区别和联系"></a>new&#x2F;malloc&#x2F;calloc的区别和联系</h2><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><p><strong>new</strong>和<strong>delete</strong>是一对，需要配对使用，是C++的<strong>运算符</strong><br><strong>malloca</strong>和<strong>free</strong>是一对，最好配对使用，是C的<strong>标准库函数</strong></p>
<p>相同点：</p>
<ul>
<li>都用于申请动态内存空间</li>
</ul>
<p>不同点：</p>
<ul>
<li>new申请的空间有可能来自于<strong>自由存储区</strong>，但是malloc申请的空间一定是<strong>堆空间</strong></li>
<li>new可以根据类型自动计算存储空间；而malloc需要手动计算</li>
<li>对于类对象来说，malloc无法满足动态对象的要求，而new和delete会在对象创建和销毁时分别调用<strong>构造函数</strong>和<strong>析构函数</strong>，所以new分为2步：内存申请和构造</li>
<li>new申请成功后返回的是对象的指针，而malloc返回的是void *，需要强转类型</li>
<li>new是类型安全的，而malloc不是类型安全的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ptr = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">2</span>];   <span class="comment">//编译会报错</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">size</span>(<span class="type">float</span>) * <span class="number">2</span>);   <span class="comment">//编译不会报错</span></span><br></pre></td></tr></table></figure></li>
<li>new是运算符，所以可以重载；但malloc函数不能重载</li>
<li>malloc可以通过relloc来修改申请的空间大小，但new申请完空间久不能再变了</li>
</ul>
<p>有了malloc&amp;free，为何还需要new&amp;delete：</p>
<blockquote>
<p>malloc&amp;free不能操作动态对象的要求，即无法自动调用构造和析构</p>
</blockquote>
<p>有了new&amp;delete，为何不删除malloc&amp;free：</p>
<blockquote>
<p>C++经常还要调用C的函数，所以涉及到的部分必须使用malloc&amp;free进行动态内存操作</p>
</blockquote>
<h3 id="malloc和calloc的区别"><a href="#malloc和calloc的区别" class="headerlink" title="malloc和calloc的区别"></a>malloc和calloc的区别</h3><p>相同点：</p>
<ul>
<li>二者都可以用来申请动态内存</li>
<li>二者都是从堆上申请空间</li>
<li>二者申请的空间都是地址连续的内存空间</li>
<li>二者申请的空间都使用free释放</li>
</ul>
<p>不同点：</p>
<ul>
<li>参数数量不同：malloc一个参数用于指定申请的内存空间大小；calloc两个参数，分别用于指定对象个数和每个对象的大小</li>
<li>内存初始化不同：malloc申请的内存不会初始化；calloc申请的内存会自动初始化为全0</li>
<li>运行效率不同，malloc比calloc厉害（主要原因初始化操作耗时）</li>
</ul>
<h2 id="size-t："><a href="#size-t：" class="headerlink" title="size_t："></a>size_t：</h2><p>size_t是一种数据类型，是无符号整数，与平台无关，取值范围为0-MAXINT（是int的2倍），不同系统中对size_t中有不同的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内联函数inline："><a href="#内联函数inline：" class="headerlink" title="内联函数inline："></a>内联函数inline：</h2><p><code>inline</code>修饰的函数其实在编译时就是直接代码的替换，这个和用<code>define</code>修饰的作用是一样，主要的目的就是为了避免对一些简单、常用的函数多次调用，影响执行效率；但是<code>inline</code>比<code>define</code>高级的地方就在于<code>inline</code>能够在编译时进行类型检查，避免一些基础错误，而且inline函数可以进行调试，但define不行<br><code>inline</code>函数可以在头文件中被定义，在其他源文件使用，<code>inline</code>关键字一定要跟函数定义绑定，<code>inline</code>放在函数声明中时无任何作用的<br>类内部除了虚函数之外的其他函数，默认都是内联函数</p>
<h2 id="volatile："><a href="#volatile：" class="headerlink" title="volatile："></a>volatile：</h2><p><code>volatile</code>关键字修饰变量的主要目的是防止编译过度优化，而产生对变量的访问错误，用<code>volatile</code>修饰过的变量一定会按照正常的指令执行顺序执行，且每次访问该变量都是直接访问内存，而不是寄存器（有时编译器为了优化读取，可能病不会把修改后的结果直接写会内存，而是缓存在寄存器中，这样别的地方访问的时候就出现了不一致的问题）</p>
<h2 id="extern-C关键字："><a href="#extern-C关键字：" class="headerlink" title="extern C关键字："></a><code>extern C</code>关键字：</h2><p>C++中有重载，所以在编译的时候函数名并不完全等于函数，而是会把修饰符、参数都加到函数名中去，但是C里边没重载，所以不会；在C++中调用C的代码时，默认按照C++的命名规则去符号表查找函数，这样很多情况下会出错，所以为了避免这种情况，所以用extern C修饰函数，这样C++编译器就会知道到底应该找哪个了名字了，不然很可能找不到</p>
<h2 id="strcpy的缺陷："><a href="#strcpy的缺陷：" class="headerlink" title="strcpy的缺陷："></a>strcpy的缺陷：</h2><p><code>strcpy</code>是用来进行字符串拷贝的函数，作用是将一块连续地址空间内的字符拷贝到另外一个连续地址空间内，包括结束符<code>\0</code>，但并不会检查目的缓冲区的大小，所以把一个大字符串拷贝到小空间的话，会覆盖其他不属于目的变量的内存空间，导致缓冲区溢出</p>
<h2 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h2><blockquote>
<p>自由存储区是C++专门针对new&amp;delete运算符的一个抽闲概念而已，而<strong>堆</strong>则是操作系统中为程序运行过程中可动态分配的内存空间的定义，所以从实际意义上讲，堆等价于动态内存空间，而自由存储区并不等价；但是由于大多数编译器中对于new的实现都是基于malloc，因此实际上绝大多数自由存储区和堆都对应相同的存储空间，所以这个自由存储区和堆是否划等号，要看new的实际实现。<br>此外，new是可以重载的，重载后的内存完全可以不在动态内存区域</p>
</blockquote>
<h2 id="左值-右值："><a href="#左值-右值：" class="headerlink" title="左值&#x2F;右值："></a>左值&#x2F;右值：</h2><h3 id="左值-右值：-1"><a href="#左值-右值：-1" class="headerlink" title="左值&#x2F;右值："></a>左值&#x2F;右值：</h3><p><strong>左值：</strong> 执行表达式之后仍然存在的对象，仍然可以通过取地址符来获取地址<br><strong>右值：</strong> 执行表达式之后已经销毁的临时对象，不能再通过取地址符&amp;来对其地址进行访问</p>
<p>在使用<code>=</code>赋值时，左边只能是左值，右值只能在右边，当然左值也可以在右边<br>函数的返回值，既可以是左值，也可以是右值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值，666 为右值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">666</span>;   <span class="comment">// ok </span></span><br><span class="line"><span class="type">int</span> *y = x; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> *z = &amp;<span class="number">666</span> <span class="comment">// error</span></span><br><span class="line"><span class="number">666</span> = x; <span class="comment">// error</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>; <span class="comment">// a 为左值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">4</span>; <span class="comment">// b 为左值</span></span><br><span class="line"><span class="type">int</span> c = a + b <span class="comment">// c 为左值 , a + b 为右值</span></span><br><span class="line">a + b = <span class="number">42</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="左值引用-右值引用："><a href="#左值引用-右值引用：" class="headerlink" title="左值引用&#x2F;右值引用："></a>左值引用&#x2F;右值引用：</h3><h3 id="左值引用："><a href="#左值引用：" class="headerlink" title="左值引用："></a>左值引用：</h3><p>顾名思义，就是对左值的引用，用<code>&amp;</code>来表示，底层是指针实现的<br>如下是左值引用的一些特殊限定：</p>
<ul>
<li>左值引用分为：常量左值引用；非常量左值引用</li>
<li>非常量左值引用只能绑定到非常量左值上，不能绑定到常量左值和右值上</li>
<li>常量左值引用可以绑定到非常量左值，常量左值、右值上</li>
</ul>
<h2 id="右值引用："><a href="#右值引用：" class="headerlink" title="右值引用："></a>右值引用：</h2><p>顾名思义，就是对右值的引用，用<code>&amp;&amp;</code>来表示，是C++ 11引入的新特性，主要的作用是实现<strong>转移语义</strong>和<strong>精确传递</strong><br><strong>转移语义</strong>：通过对右值绑定引用，使得临时对象不会立即释放了，临时对象内存的声明周期和对应的右值引用一致了，特别是类似于移动构造的使用下，能够避免大规模的内存拷贝<br><strong>精确传递</strong>：其实也是利用了在实现参数传递的时候避免了拷贝等操作</p>
<p>右值引用必须绑定到右值上</p>
<p>可以通过std:move将一个左值强制转换为右值，实现转移引用，通过右值引用访问左值</p>
<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>所谓移动构造函数，就是在用一个对象初始化另外一个对象的时候，不需要做内存拷贝，而是只做内存和对象关系的移动，说白了就是我把我的身体给你，我自己灵魂出窍了（升天了，要g了）</p>
<p>⚠️：正常情况下移动构造的实参一定是右值，但是如果非得用左值，那就用move把左值转换为右值</p>
<h3 id="移动构造和拷贝构造："><a href="#移动构造和拷贝构造：" class="headerlink" title="移动构造和拷贝构造："></a>移动构造和拷贝构造：</h3><p>移动构造入参：右值引用<br>拷贝构造入参：左值引用<br>正常情况下使用<strong>临时对象</strong>初始化一个新对象时，会先尝试使用移动构造，如果移动构造没有定义，则才会使用拷贝构造</p>
<p>之所以用移动构造，就是为了防止对象内部有指针变量，如果用拷贝构造，那么就需要将指针的地址拷贝一份出来，效率和代价比较大；但是用了移动构造，指针指向的空间不用内存拷贝了，直接用新对象的指针变量指向老对象的内存，然后将老对象的指针置为NULL。</p>
<h2 id="move函数的实现原理："><a href="#move函数的实现原理：" class="headerlink" title="move函数的实现原理："></a>move函数的实现原理：</h2><p><del>待补充</del></p>
<h2 id="智能指针："><a href="#智能指针：" class="headerlink" title="智能指针："></a>智能指针：</h2><p>使用智能指针的目的就是为了防止内存泄露，也就是申请的内存在使用完毕后没有释放<br>智能指针在C++11中引入（其实C++ 98中也有auto_ptr，只是比较简单，场景受限），C++ 11中的3种智能指针：</p>
<h3 id="智能指针的三个重要函数："><a href="#智能指针的三个重要函数：" class="headerlink" title="智能指针的三个重要函数："></a>智能指针的三个重要函数：</h3><ul>
<li>**get()**：返回智能指针托管的内存地址，但是一般不用，因为我们就是想着不用去直接操作内存才有的这些高级封装操作</li>
<li>**release()**：取消智能指针对内存的托管</li>
<li>**reset()**：充值智能指针托管的内存，参数为空，则重置为NULL</li>
</ul>
<h3 id="auto-ptr比unique-ptr差的地方："><a href="#auto-ptr比unique-ptr差的地方：" class="headerlink" title="auto_ptr比unique_ptr差的地方："></a>auto_ptr比unique_ptr差的地方：</h3><ul>
<li>拷贝和赋值都会改变智能指针对内存的所有权</li>
<li>STL容器中使用auto_ptr存在很大风险，因为STL内元素必须支持拷贝&amp;赋值</li>
<li>auto_ptr不支持对象数组的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;AAAA&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">auto_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;BBBB&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 address: &quot;</span> &lt;&lt; p1.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 addrees: &quot;</span> &lt;&lt; p2.<span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">    p1 = p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 address: &quot;</span> &lt;&lt; p1.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 addrees: &quot;</span> &lt;&lt; p2.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line">P1 address: <span class="number">1234</span>****</span><br><span class="line">P2 address: <span class="number">4567</span>****</span><br><span class="line"></span><br><span class="line">P1 address: <span class="number">1234</span>****</span><br><span class="line">P2 address: <span class="number">00000000</span>    <span class="comment">//auto_ptr的拷贝复制会改变资源所有权，强制将P2置为NULL</span></span><br></pre></td></tr></table></figure>


<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr:"></a>unique_ptr:</h3><p>这种智能指针只是是不允许多个指针指向同一对象内存空间的，即独享所有权的指针，不支持拷贝构造、复制<br>需要注意的是unique_ptr在调用reset的时候，会赋新值<br>因为unique_ptr因为自身不允许多个智能指针指向同一内存的缺陷，它有可能造成悬空智能指针，比如下面的代码中，由p1先管理str，但是后边p2作为独占管理，那么此时如果用p1访问的话就会报错了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt;string&gt; p1;</span><br><span class="line">string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;智能指针的内存管理陷阱&quot;</span>);</span><br><span class="line">p1.<span class="built_in">reset</span>(str);	<span class="comment">// p1托管str指针</span></span><br><span class="line">&#123;</span><br><span class="line">	auto_ptr&lt;string&gt; p2;</span><br><span class="line">	p2.<span class="built_in">reset</span>(str);	<span class="comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str：&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


<h3 id="share-ptr："><a href="#share-ptr：" class="headerlink" title="share_ptr："></a>share_ptr：</h3><p>share_ptr是允许多个智能指针同时管理一个对象的内存空间的，用计数器实现，当某个智能指针析构时，会检查计数器，如果计数器等于0，则证明没有指针指向这块内存，则释放内存；而当执行智能指针赋值、拷贝构造时就会让计数器+1，通过如下的例子可以感受share_ptr的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;string&gt; p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;111&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 account: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 account: &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    p1 = p2;    <span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 account: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 account: &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(p1)</span></span>;  <span class="comment">//拷贝构造</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 account: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 account: &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3 account: &quot;</span> &lt;&lt; p3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果 */</span></span><br><span class="line"><span class="comment">// p1 account: 0</span></span><br><span class="line"><span class="comment">// p2 account: 1</span></span><br><span class="line"><span class="comment">// p1 account: 2</span></span><br><span class="line"><span class="comment">// p2 account: 2</span></span><br><span class="line"><span class="comment">// p1 account: 3</span></span><br><span class="line"><span class="comment">// p2 account: 3</span></span><br><span class="line"><span class="comment">// p3 account: 3</span></span><br></pre></td></tr></table></figure>

<p>share_ptr可以用make_shared来初始化（更快）：<code>shared_ptr&lt;string&gt; p1 = make_shared&lt;string&gt;(&quot;AAAA&quot;)</code></p>
<p>share_ptr可以交换彼此的托管，彼此的计数不变：<code>p1.swap(p2); std:swap(p1, p2);</code></p>
<p><strong>shared_ptr的使用缺陷场景：</strong> 多个类交叉包含彼此对象的智能指针，会造成内存泄漏，无法释放的问题，交叉持有对方智能指针对象时，引用计数为2，但是每个对象在析构时又只会释放一次，也就是计数器只会-1，所以内存不会释放</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>为了解决上述shared_ptr的交叉持有时释放不了的情况，引入了weak_ptr来协助shared_ptr，weakptr的构造和析构不会引起计数器的增减，weakptr不支持<code>*</code>和<code>-&gt;</code>的重载，所以没法访问对象，如果一定要访问，那就在对象内部将weakptr转换成共享指针 lock()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Girl&gt; sp_girl;</span><br><span class="line">sp_girl = wpGirl_1.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完之后，再将共享指针置NULL即可</span></span><br><span class="line">sp_girl = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="值传递、引用传递、指针传递"><a href="#值传递、引用传递、指针传递" class="headerlink" title="值传递、引用传递、指针传递"></a>值传递、引用传递、指针传递</h2><p>函数调用时有三种参数传递的方式：</p>
<h3 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h3><p>通过值的内存拷贝，实现参数传递，其实就是把实参的值给形参拷贝了一份</p>
<h3 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h3><p>形参就是实参的引用，所以函数内部的修改会影响实参的值</p>
<h3 id="指针传递："><a href="#指针传递：" class="headerlink" title="指针传递："></a>指针传递：</h3><p>本质上时值的传递，只不过拷贝的是指针的值，也就是说把对实参的指针的值拷贝了一份给形参</p>
<h2 id="结构体相等的判断方式："><a href="#结构体相等的判断方式：" class="headerlink" title="结构体相等的判断方式："></a>结构体相等的判断方式：</h2><p>如果在C++种想判断2个结构体是否相等，不能直接用<code>memcmp</code>函数，因为结构体是内存对齐的，所以内存种免不了有垃圾数据，而<code>memcmp</code>是按字节比较的，所以不能用<code>memcmp</code>，只能通过重载<code>==</code>运算符，对结构体内元素逐一比较</p>
<h2 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h2><h3 id="C语言中的强制类型转换："><a href="#C语言中的强制类型转换：" class="headerlink" title="C语言中的强制类型转换："></a>C语言中的强制类型转换：</h3><p>C语言中的强制类型转换主要是为了基础数据类型之间的转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(类型)expression</span><br><span class="line">类型(expression)</span><br></pre></td></tr></table></figure>
<h3 id="C-中的强制类型转换："><a href="#C-中的强制类型转换：" class="headerlink" title="C++中的强制类型转换："></a>C++中的强制类型转换：</h3><p>C++除了保留C中的基础数据类型的强制转换之外，还针对面向对象的类，引入了一些基类与派生类之间继承关系转化的相关操作，共有四种：<code>static_cast</code>，<code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code></p>
<h4 id="static-cast："><a href="#static-cast：" class="headerlink" title="static_cast："></a>static_cast：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>(<span class="keyword">new</span> type) expression;</span><br></pre></td></tr></table></figure>
<p>常用的4种用法：</p>
<ol>
<li>把空指针转换为任何类型的指针</li>
<li>把任何类型的表达式转换为void类型</li>
<li>基础数据类型转换</li>
<li>基类和派生类的上行&#x2F;下行类型转换</li>
</ol>
<h4 id="dynamic-cast："><a href="#dynamic-cast：" class="headerlink" title="dynamic_cast："></a>dynamic_cast：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>：(<span class="keyword">new</span> type) expression;</span><br></pre></td></tr></table></figure>
<h4 id="const-cast："><a href="#const-cast：" class="headerlink" title="const_cast："></a>const_cast：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>：(<span class="keyword">new</span> type) expression;</span><br></pre></td></tr></table></figure>
<h4 id="reinterpret-cast："><a href="#reinterpret-cast：" class="headerlink" title="reinterpret_cast："></a>reinterpret_cast：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reinterpret</span>(<span class="keyword">new</span> type) expression;</span><br></pre></td></tr></table></figure>


<h2 id="一些高级概念："><a href="#一些高级概念：" class="headerlink" title="一些高级概念："></a>一些高级概念：</h2><h3 id="泛型编程（模版）："><a href="#泛型编程（模版）：" class="headerlink" title="泛型编程（模版）："></a>泛型编程（模版）：</h3><p>泛型是一种思想：让相同的函数或类能够处理不同的数据结构，一般通过定义模版实现，主要的作用就是：通用型、效率</p>
<h4 id="函数模版："><a href="#函数模版：" class="headerlink" title="函数模版："></a>函数模版：</h4><p>使用类型声明函数模版的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> identifier&gt; declaration;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">identifier</span>&gt; declaration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> T&gt; T <span class="title">max</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a, b;&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="类模版："><a href="#类模版：" class="headerlink" title="类模版："></a>类模版：</h4><p>类模版的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>类模版的使用举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NameType name;</span><br><span class="line">    AgeType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span>&lt;&lt; name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;ZhangSan&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">showInfo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意⚠️：</p>
<ul>
<li>如果基类为类模版，派生类需要指定模版中的类型，否则编译报错，因为编译器不知道分配多少内存</li>
<li>如果派生类也想灵活给出模版中参数类型，那就要求派生类也为类模版实现</li>
</ul>
<h4 id="变量模版："><a href="#变量模版：" class="headerlink" title="变量模版："></a>变量模版：</h4><p><del>待补充</del></p>
<h4 id="函数重载和函数模版的区别："><a href="#函数重载和函数模版的区别：" class="headerlink" title="函数重载和函数模版的区别："></a>函数重载和函数模版的区别：</h4><ul>
<li><code>相同点</code>：都是多态的实现方式，且不管是重载还是模版，在编译的时候都是生成多个函数代码的，目标代码不会变少，但是通过模版可以减少写代码</li>
<li><code>不同点</code>：函数操作相似用重载；函数操作相同用模版</li>
</ul>
<h4 id="函数模版和类模版的区别："><a href="#函数模版和类模版的区别：" class="headerlink" title="函数模版和类模版的区别："></a>函数模版和类模版的区别：</h4><ul>
<li>自动类型推导：类模版无自动类型推导；函数模版有自动类型推导</li>
<li>类模版可以接受默认参数，函数模版不能使用默认参数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">TypeName</span>, <span class="type">int</span> a&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">TypeName</span>, <span class="type">int</span> a = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> B &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL："><a href="#STL：" class="headerlink" title="STL："></a>STL：</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">教程</a><br>STL是C++种提供的标准模版库，主要依赖模版实现，内置了很多函数模版、类模版供使用，STL一般情况下是数据和操作分离的，比如sort函数，我们可以用来对数组、链表、容器等进行排序。</p>
<h4 id="STL的6大组件："><a href="#STL的6大组件：" class="headerlink" title="STL的6大组件："></a>STL的6大组件：</h4><p><img src="https://img-blog.csdnimg.cn/d94761ca4b0b4976a080931159c127ea.png" alt="STL6大组件"></p>
<h5 id="容器"><a href="#容器" class="headerlink" title="容器:"></a>容器:</h5><p>包括2个大类：<br>1、序列容器：<code>向量（vector）</code>、<code>列表（list）</code>、<code>双端队列（deque）</code><br>2、关联容器：<code>集合（set）</code>、<code>multiset</code>、<code>映射（map）</code>、<code>multimap</code><br>STL的容器用于存储和管理数据，容器类自动申请和释放内存，无需new和delete操作</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html">几种容器的比较</a></p>
<h6 id="容器的概要及使用原则："><a href="#容器的概要及使用原则：" class="headerlink" title="容器的概要及使用原则："></a>容器的概要及使用原则：</h6><p><img src="https://img-blog.csdnimg.cn/6ff5df7fd4244cc7b6720ceae90f9eec.png" alt="容器的概要"></p>
<ul>
<li>最常用的容器就是vector</li>
<li>如果程序有很多小元素且空间的额外开销很重要，不要使用list或forward_list</li>
<li>要求随机访问元素，应该使用vector或deque</li>
<li>要求中间插入或删除元素，应该使用list或forward_list</li>
<li>要求在头尾插入或删除元素，且中间不进行插入或删除，应该使用deque</li>
<li>如果只在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素（首先可以考虑在读取输入时使用vector，再调用sort函数重排容器中的元素，从而避免在中间位置添加元素。如果必须在中间位置插入元素，考虑在输入阶段使用list，输入完成将list拷贝到vector中）</li>
<li>如果实在不确定使用哪种容器，可以在程序中只使用vector和list的公共操作迭代器而非下标，避免随机访问。这样可以在必要时选择使用vector或list</li>
</ul>
<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器:"></a>迭代器:</h5><p>提供了一种访问容器中元素的通用方式，迭代器通常用来遍历容器内容，但是并不需要关心容器的内部实现，一般情况下基于迭代器，用户可以自定实现一些算法，包括<code>输入迭代器</code>、<code>输出迭代器</code>、<code>前向迭代器</code>、<code>双向迭代器</code>和<code>随机访问迭代器</code></p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法:"></a>算法:</h5><p>包括<code>排序</code>、<code>查找</code>、<code>遍历</code>、<code>修改</code>、<code>复制</code>、<code>合并</code>、<code>反转</code>、<code>旋转</code>等常用算法，通常算法和所操作的数据是分离的<br>这个数据和算法分离的概念可以这么理解，就是一个sort算法，可以适应的是所有类型的容器，比如list中的对象可以是int，也可以是个很复杂的类对象，sort函数不care，照样弄你</p>
<h5 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数:"></a>仿函数:</h5><p>是可调用对象，可以像函数一样使用，用于定制算法的行为，说白了就是让类像函数一样使用</p>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器:"></a>适配器:</h5><p>用于将容器或函数对象转换成其他类型，以适应不同的需求。包括<code>容器适配器（如栈和队列的适配器）</code>、<code>迭代器适配器（如反向迭代器和插入迭代器）</code>和<code>函数适配器（如绑定器和取反器）</code></p>
<h5 id="空间配置器件"><a href="#空间配置器件" class="headerlink" title="空间配置器件:"></a>空间配置器件:</h5><p>用于管理动态内存的分配和释放</p>
<h4 id="STL的缺陷："><a href="#STL的缺陷：" class="headerlink" title="STL的缺陷："></a>STL的缺陷：</h4><ul>
<li>STL非线程安全的，需要使用者自己加锁，普通情况下锁的粒度会很大</li>
<li>STL极度追求效率，导致内部实现比较复杂</li>
</ul>
<h4 id="vector中reserve和resize的区别："><a href="#vector中reserve和resize的区别：" class="headerlink" title="vector中reserve和resize的区别："></a>vector中reserve和resize的区别：</h4><p>首现需要明确2个概念，<code>capacity</code>和<code>size</code>，其中：<br><code>capacity</code>：vector最多能容纳的元素个数<br><code>size</code>：现在vector有效的元素个数</p>
<h5 id="Reserve："><a href="#Reserve：" class="headerlink" title="Reserve："></a>Reserve：</h5><p>修改当前vector的capacity，但是不做初始化</p>
<h5 id="Resieze："><a href="#Resieze：" class="headerlink" title="Resieze："></a>Resieze：</h5><p>修改当前vector的有效元素个数，会做初始化，有可能会改变capacity</p>
<h4 id="模版特化："><a href="#模版特化：" class="headerlink" title="模版特化："></a>模版特化：</h4><p>所谓模版特化，即模版的参数并不都是同一种类型，有全特化、部分特化两种。特化的主要原因是，一些模版在接受某些特定类型参数时可能报错，所以为了排除这种问题，定义模版时将部份或全部参数指定为特定的类型</p>
<h4 id="类型萃取："><a href="#类型萃取：" class="headerlink" title="类型萃取："></a>类型萃取：</h4><p>在模版内部需要针对不同类型的数据做区分处理时，需要识别参数的类型，这个操作就叫类型萃取，和特化做个对比就是知道，特化是限制模版参数输入，而类型萃取是在模版内部对类型做限制</p>
<hr>
<h2 id="C-11的新特性："><a href="#C-11的新特性：" class="headerlink" title="C++ 11的新特性："></a>C++ 11的新特性：</h2><h3 id="auto类型推导："><a href="#auto类型推导：" class="headerlink" title="auto类型推导："></a>auto类型推导：</h3><p><code>auto</code>关键字是在C++11种引入的自动类型推导的关键字，可以根据<code>函数返回值</code>、<code>表达式</code>、<code>初始值</code>来自动推导出变量的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var1 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> var2 = var1;    <span class="comment">//根据初始化值自动推导类型</span></span><br><span class="line"><span class="keyword">auto</span> var3 = <span class="built_in">func</span>(); <span class="comment">//根据函数返回值自动推导类型</span></span><br><span class="line"><span class="keyword">auto</span> var4 = x1 + x2;    <span class="comment">//根据表达值结果自动推导类型</span></span><br></pre></td></tr></table></figure>
<p>⚠️注意：</p>
<ul>
<li><code>auto</code>在执行自动类型推导时会自动脱去<code>引用&amp;</code>、顶层<code>const</code>、<code>volatile</code>关键字的修饰</li>
<li><code>auto</code>修饰的变量在定义是必须初始化，这是因为<code>auto</code>关键字是在编译阶段生效的，如果没有初始化，则无法知道对应变量的类型了</li>
</ul>
<h3 id="decltype类型推导："><a href="#decltype类型推导：" class="headerlink" title="decltype类型推导："></a>decltype类型推导：</h3><p>其实和<code>auto</code>一样，<code>decltype</code>用来做类型推导的，和<code>auto</code>的区别也很明显，<code>auto</code>在做类型推导的同时要赋值，但是<code>decltype</code>就只做类型的提取，不做赋值</p>
<h3 id="lambda表达式："><a href="#lambda表达式：" class="headerlink" title="lambda表达式："></a>lambda表达式：</h3><p>又被成为匿名函数，主要的作用就是为了写程序方便，可以就地定义函数，而不需要去别的地方做函数定义、函数声明等一系列麻烦的操作，让程序员更加专心眼前的逻辑处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">    function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<strong>捕获列表</strong>：指定lambda表达时内部需要使用的局部变量，一般被称作<code>闭包</code>，如下所示为一些常用的闭包：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      <span class="comment">// 没有定义任何变量。使用未定义变量会引发错误</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用</span></span><br></pre></td></tr></table></figure>
<p>⚠️注意：lambda表达式是在捕获列表中是以<code>值方式</code>对环境中的变量进行捕获的，在lambda表达式内部不能进行修改，否则编译报错。如果想强行在lambda中修改，必须在表达式中加入<code>mutalbe</code>关键字修饰，而且对于同一个捕获来说，后续对lambda的重复使用将对捕获时的值叠加作用，但是对捕获外部的原始值没有影响</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 编译报错：表达式必须是可修改的左值 */</span></span><br><span class="line">    <span class="comment">// auto func = [a] &#123;</span></span><br><span class="line">    <span class="comment">//     a = a + 1;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [a] <span class="keyword">mutable</span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;out: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a  = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;out: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a><a href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC">右值引用</a></h3><h3 id="move函数"><a href="#move函数" class="headerlink" title="move函数"></a><a href="#move%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">move函数</a></h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针</a></h3><h3 id="使用-禁止对象的默认构造函数："><a href="#使用-禁止对象的默认构造函数：" class="headerlink" title="使用&#x2F;禁止对象的默认构造函数："></a>使用&#x2F;禁止对象的默认构造函数：</h3><p>C++11中允许显式的说明使用&#x2F;禁止编译器提供的内置函数，分别使用default和delete修饰符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ClassA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">const</span> A &amp;) = <span class="keyword">delete</span>;     <span class="comment">//禁止类对象的拷贝构造</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">//禁止类对象拷贝赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr:"></a><a href="#const%E9%99%90%E5%AE%9A%E7%AC%A6">constexpr</a>:</h3><h3 id="nullptr："><a href="#nullptr：" class="headerlink" title="nullptr："></a>nullptr：</h3><p>C++11中为了将空指针和0区分开，引入了nullptr，是有类型的，说白了就是nullptr可以转化为任何类型的指针，因为在以前指针为空用NULL来表示，但实际上NULL是一个宏定义，它就是0，如果在重载函数场景下用NULL的话，可能造成函数调用歧义</p>
<h3 id="可扩展的随机数："><a href="#可扩展的随机数：" class="headerlink" title="可扩展的随机数："></a>可扩展的随机数：</h3><h2 id="C-11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎-随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布"><a href="#C-11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎-随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布" class="headerlink" title="C++11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎+随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布"></a>C++11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎+随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, <span class="number">99</span>)</span></span>; <span class="comment">// 离散型均匀分布</span></span><br><span class="line">std::mt19937 engine; <span class="comment">// 随机数生成引擎</span></span><br><span class="line"><span class="keyword">auto</span> generator = std::<span class="built_in">bind</span>(distribution, engine); <span class="comment">// 将随机数生成引擎和分布绑定生成函数</span></span><br><span class="line"><span class="type">int</span> random = <span class="built_in">generator</span>();  <span class="comment">// 产生随机数</span></span><br></pre></td></tr></table></figure></h2><h1 id="C-的面向对象："><a href="#C-的面向对象：" class="headerlink" title="C++的面向对象："></a>C++的面向对象：</h1><h2 id="面向对象的三大特征："><a href="#面向对象的三大特征：" class="headerlink" title="面向对象的三大特征："></a>面向对象的三大特征：</h2><ul>
<li>继承：子类可以继承父类的特征和行为，包含成员变量和函数</li>
<li>多态：C++中主要是利用虚函数实现，即不同的继承类对象对同一调用做出不同的反应</li>
<li>封装：将某个操作封装成为具体的函数，只能通过接口方式调用，降低了耦合性</li>
</ul>
<h2 id="函数的重载-重写-隐藏："><a href="#函数的重载-重写-隐藏：" class="headerlink" title="函数的重载&#x2F;重写&#x2F;隐藏："></a>函数的重载&#x2F;重写&#x2F;隐藏：</h2><ul>
<li><p>重载：就是同名的函数，通过不同的参数来进行区分，而且不区分返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg3)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写：重写值得是派生类对基类中用<strong>virtual</strong>关键字修饰的函数，对其函数体进行重写的操作，但是不会修改函数的返回值和参数，利用重写可以实现多态</p>
</li>
<li><p>隐藏：派生类中隐藏基类的同名函数，不管参数列表是否相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> :</span> public Base &#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg1 * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Device dev;</span><br><span class="line">    dev.func(<span class="number">1</span>);    <span class="comment">//ok</span></span><br><span class="line">    dev.func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//error, 因为这里派生类隐藏了基类的同名函数，如果需要访问则需要：</span></span><br><span class="line"></span><br><span class="line">    dev.Base::func(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//需要明确指定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写&#x2F;重载的区别：</p>
<ul>
<li>范围：重写值得是子类重写父类的函数；而重载是在某个类的内部对某个名字的函数进行不同的实现</li>
<li>参数区别：重载可以要求函数有不同的返回值、参数；但是重写要求返回值和参数都一致，只修改函数内部实现逻辑</li>
<li>关键字修饰：重写的函数必须是基类中用<strong>virtual</strong>修饰的才行</li>
</ul>
</li>
</ul>
<h2 id="多态的总结："><a href="#多态的总结：" class="headerlink" title="多态的总结："></a>多态的总结：</h2><ul>
<li>多态就是用虚函数实现的，每个有虚函数的类都会有一个虚函数表，并为类对象中有个虚表指针指向虚表</li>
<li>虚函数是在运行时根据对象动态绑定，由对象决定，也就是说不管用基类的指针还会子类的指针，只要指向的对象是子类，那就用子类的函数，如果指向的是基类，那就用基类的函数</li>
<li>函数隐藏的情况下，基类指针指向子类对象时，其实仍然访问的是基类的函数，也就是说函数隐藏取决于指针类型，而重写取决于对象</li>
<li></li>
</ul>
<h2 id="虚函数和纯虚函数："><a href="#虚函数和纯虚函数：" class="headerlink" title="虚函数和纯虚函数："></a>虚函数和纯虚函数：</h2><p>虚函数是派生类可以重写的，但是不一定需要重写，看需求；但是纯虚函数就要求派生类必须实现纯虚函数的实现，如果不实现编译时会报错，那派生类仍然是个抽象类，而抽象类是不能进行对象实例化、作入参、做返回值的<br>理解下来就是说：虚函数都是用来实现多态的，但是纯虚函数的定存在，就是为了派生类必须要做某个动作的定义，如果不定义那就直接报错了，所以正常情况下推荐将析构函数定义为纯虚函数，这样就不会忘了在派生类中定义析构了</p>
<ul>
<li>构造函数不能定义为虚函数：虚函数是又了对象之后，才会有的，但是有类对象则一定要执行构造函数，这就前后矛盾了</li>
<li>推荐将析构函数定义为虚函数：能够防止不及时回收内存导致内存泄漏</li>
</ul>
<p>⚠️注意：2个问题：<br>1、虚函数表什么时候生成，放在哪里？<br>虚函数表是在程序编译阶段生成的，虚函数表中防止的就是虚函数的起始地址，放在只读数据段<br>2、虚表指针什么时候生成，放在哪里？<br>虚表指针是在程序运行过程中对象初始化后生成的，放在类对象内存的起始位置，指向虚函数表</p>
<h2 id="虚继承："><a href="#虚继承：" class="headerlink" title="虚继承："></a>虚继承：</h2><h2 id="深拷贝-浅拷贝："><a href="#深拷贝-浅拷贝：" class="headerlink" title="深拷贝&#x2F;浅拷贝："></a>深拷贝&#x2F;浅拷贝：</h2><ul>
<li>深拷贝：完全的内存复制，每个对象对应一个单独内存空间，互补影响</li>
<li>浅拷贝：只拷贝栈空间，而不管堆</li>
</ul>
<p>所以当对象有指针变量是，推荐使用深拷贝，不然可能造成前一个对象把堆内存释放了，结果第二个对象再去访问，造成崩溃<br>为了能够保证深拷贝，则需要定义拷贝构造函数，即对新对象拷贝时，在构造函数中重新new内存出来</p>
<p>⚠️注意：类对象的深拷贝必须显式定义拷贝构造</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="友元函数："><a href="#友元函数：" class="headerlink" title="友元函数："></a>友元函数：</h3><p>通过声明友元函数，可以实现普通函数、其他类成员函数对某个类的privte&#x2F;protected成员的访问</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>通过在类中声明友元类，可以实现对其他类的private&#x2F;protected成员变量的访问</p>
<p>友元函数的2个特性：</p>
<ul>
<li><code>单向性</code>：A可以是B的友元，但B不一定是A的友元</li>
<li><code>不可传递性</code>：指的是派生类不能继承父类的友元关系</li>
</ul>
<h2 id="如何让一个类不能被继承："><a href="#如何让一个类不能被继承：" class="headerlink" title="如何让一个类不能被继承："></a>如何让一个类不能被继承：</h2><ul>
<li>方法1：用final关键字</li>
<li>方法2：使用友元、虚继承和私有构造函数来实现</li>
</ul>
<h2 id="如何让类对象不能拷贝："><a href="#如何让类对象不能拷贝：" class="headerlink" title="如何让类对象不能拷贝："></a>如何让类对象不能拷贝：</h2><ul>
<li>方法1：私有化：<ul>
<li>将<code>拷贝构造函数</code>和<code>=的重载</code>声明为private</li>
<li>派生类私有继承</li>
</ul>
</li>
<li>方法2：delete：将拷贝构造函数用<code>delete</code>修饰</li>
</ul>
<h2 id="如何让一个类不能实例化："><a href="#如何让一个类不能实例化：" class="headerlink" title="如何让一个类不能实例化："></a>如何让一个类不能实例化：</h2><ul>
<li>方法1：类中有纯虚函数，抽象类不能实例化对象</li>
<li>方法2：所有构造函数私有化</li>
<li>方法3：类的所有构造函数用<code>=delete</code>修饰</li>
</ul>
<h2 id="拷贝构造为何必须声明为引用："><a href="#拷贝构造为何必须声明为引用：" class="headerlink" title="拷贝构造为何必须声明为引用："></a>拷贝构造为何必须声明为引用：</h2><p>之所以拷贝构造函数中必须声明为引用的，是为了防止拷贝构造无限循环导致内存溢出，如下是几种拷贝构造的常见触发场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassName *p = <span class="keyword">new</span> <span class="built_in">ClassName</span>(<span class="string">&quot;test&quot;</span>);   <span class="comment">//No.1</span></span><br><span class="line"></span><br><span class="line"><span class="function">ClassName <span class="title">q</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;    <span class="comment">//No.2</span></span><br><span class="line"></span><br><span class="line">ClassName m;    <span class="comment">//No.3</span></span><br><span class="line">m = q;</span><br><span class="line"></span><br><span class="line"><span class="function">ClassName <span class="title">n</span><span class="params">(q)</span></span>;     <span class="comment">//No.4</span></span><br></pre></td></tr></table></figure>

<h2 id="实例化一个类对象的步骤："><a href="#实例化一个类对象的步骤：" class="headerlink" title="实例化一个类对象的步骤："></a>实例化一个类对象的步骤：</h2><ul>
<li>申请内存：</li>
<li>初始化：</li>
<li>赋值：构造函数做的事情，也意味着构造函数执行完毕之后，一个对象的实例化就完成了</li>
</ul>
<p>注：有虚函数的对象实例化的时候还需要给虚表指针赋值</p>
<h2 id="C-类对象的初始化顺序："><a href="#C-类对象的初始化顺序：" class="headerlink" title="C++类对象的初始化顺序："></a>C++类对象的初始化顺序：</h2><ol>
<li>调用基类的构造函数：<br> 默认按照继承说明的顺序进行调用（但是虚继承优先）</li>
<li>类成员的构造函数：按照声明的顺序调用</li>
<li>派生类自身的构造函数</li>
</ol>
<p>类成员的初始化顺序：</p>
<ol>
<li>类的static成员是main函数开始前就初始化了的</li>
<li>如果成员变量在初始化列表初始化，则按照成员在类中的声明顺序进行初始化</li>
<li>如果是在构造函数内部，则与实际的代码逻辑匹配</li>
</ol>
<h2 id="如何禁止构造函数被使用："><a href="#如何禁止构造函数被使用：" class="headerlink" title="如何禁止构造函数被使用："></a>如何禁止构造函数被使用：</h2><p><strong>构造函数私有化</strong>是一个方法，但是这种方法避免不了类内部成员、友元的访问，因此在C++引入了<code>=delete</code>关键字（<code>=default</code>是让一个构造函数可以被调用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以个人理解，正常情况下不会把所有的构造函数都不可调用，是为了让用户自定义一些构造函数，而把默认构造定义为不可调用</p>
<h2 id="使用列表初始化快的原因："><a href="#使用列表初始化快的原因：" class="headerlink" title="使用列表初始化快的原因："></a>使用列表初始化快的原因：</h2><p>如果不使用列表初始化，在构造函数内部初始化成员变量的话，会先调用默认构造函数，因此反过来说如果使用列表初始化，则省去了调用默认构造函数的开销</p>
<h2 id="静态绑定-动态绑定："><a href="#静态绑定-动态绑定：" class="headerlink" title="静态绑定&#x2F;动态绑定："></a>静态绑定&#x2F;动态绑定：</h2><ul>
<li>静态类型：对象在声明时的类型，编译阶段指定，不可更改</li>
<li>动态类型：对象当前所指的类型，运行时指定，可以更改</li>
<li>静态绑定：在编译阶段为对象指定类型的过程</li>
<li>动态绑定：在运行阶段为对象指定类型的过程</li>
</ul>
<p><strong>注：</strong> 类的成员，只有虚函数是动态绑定，其他都是静态绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is child&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Child</span>();  <span class="comment">//p的静态类型为Base，动态类型为Child</span></span><br><span class="line">    p-&gt;<span class="built_in">func</span>();  <span class="comment">//func的调用取决于指针所指对象类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的，虚函数指向虚函数表，虚函数表中放的是虚函数的入口地址</p>
<p>基类和派生类的同名虚函数在虚函数表中的偏移是一致的，如果没有重写虚函数，那就派生类和基类相同偏移的函数都是一致的，如果有重写，那派生类就替换相同偏移位置的虚函数入口地址，如果派生类中新定义了非同名虚函数，那就直接在虚函数表末尾加入</p>
<h2 id="编译时多态-运行时多态"><a href="#编译时多态-运行时多态" class="headerlink" title="编译时多态&#x2F;运行时多态"></a>编译时多态&#x2F;运行时多态</h2><h3 id="编译时多态："><a href="#编译时多态：" class="headerlink" title="编译时多态："></a>编译时多态：</h3><p>实际指的是<code>模版</code>、<code>重载(泛型)</code>，编译时都会生成不同的函数，比如重载，在代码段中都是不同的函数</p>
<h3 id="运行时多态："><a href="#运行时多态：" class="headerlink" title="运行时多态："></a>运行时多态：</h3><p>实际指的是类的多态，其实就是虚函数，指的是用基类<code>指针</code>&#x2F;<code>引用</code>访问派生类虚函数</p>
<h3 id="两者的区别："><a href="#两者的区别：" class="headerlink" title="两者的区别："></a>两者的区别：</h3><ul>
<li>发生时期不同：<code>编译时多态-编译阶段</code>；<code>运行时多态-运行阶段</code></li>
<li>实现方式不同：<code>编译时多态-泛型编程</code>；<code>运行时多态-虚函数表</code></li>
</ul>
<h2 id="如何让成员函数不可改变成员变量的值："><a href="#如何让成员函数不可改变成员变量的值：" class="headerlink" title="如何让成员函数不可改变成员变量的值："></a>如何让成员函数不可改变成员变量的值：</h2><p>将成员函数用<code>const</code>修饰，即可做到让该函数无法修改成员变量的值，但是如果就是想在<code>const</code>函数内部修改某个成员变量的值，也有办法：将该成员变量声明时加上<code>mutable</code>关键字的修饰(被mutable修饰的变量将处于永远可以被修改的状态)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> var2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClas</span>() &#123;</span><br><span class="line">        var1 = <span class="number">10</span>;</span><br><span class="line">        var2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        var1 = <span class="number">100</span>; <span class="comment">//error, 现实变量为只读类型</span></span><br><span class="line">        var2 =  <span class="number">200</span>;    <span class="comment">//ok，可以修改var2的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限制对象内存在栈-堆："><a href="#限制对象内存在栈-堆：" class="headerlink" title="限制对象内存在栈&#x2F;堆："></a>限制对象内存在栈&#x2F;堆：</h2><h3 id="限制类对象的内存在栈："><a href="#限制类对象的内存在栈：" class="headerlink" title="限制类对象的内存在栈："></a>限制类对象的内存在栈：</h3><p>在类的内部私有化重载new和delete运算符（<del><strong>底层的原理是啥呢？</strong></del>）</p>
<h3 id="限制类对象的内存在堆："><a href="#限制类对象的内存在堆：" class="headerlink" title="限制类对象的内存在堆："></a>限制类对象的内存在堆：</h3><p>可以尝试将析构函数私有化，这样在函数检查时发现如果将内存放在栈里头，因为析构函数私有化，那么久没发释放内存，程序就执行不下去了</p>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="进程间通信的方式："><a href="#进程间通信的方式：" class="headerlink" title="进程间通信的方式："></a>进程间通信的方式：</h2><p>进程间通信的方式一共有4种：共享内存、管道、消息队列、文件<br>线程间通信的方式：共享内存</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>用于防止多个线程对同一个共享变量同时操作（同时访问临界区变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std:mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; c</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std:<span class="function">thread <span class="title">th1</span><span class="params">(func, <span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    std:<span class="function">thread <span class="title">th2</span><span class="params">(func, <span class="string">&#x27;B&#x27;</span>)</span></span>;</span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果 */</span></span><br><span class="line"><span class="comment">// AAAAAAAAAA</span></span><br><span class="line"><span class="comment">// BBBBBBBBBB</span></span><br></pre></td></tr></table></figure>
<h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>用于限制多个线程同时<strong>读取&#x2F;写入</strong>，这里强调的是读和写都是一样的</p>
<h3 id="共享互斥量："><a href="#共享互斥量：" class="headerlink" title="共享互斥量："></a>共享互斥量：</h3><p><code>std::shared_mutex</code>跟普通的互斥量有区别，使用场景是：允许同时进行多个读取，但读取还是只能一个，当然读取和写入还是互斥的，<code>std::shared_mutex</code>配合<code>unique_lock</code>和<code>shared_lock</code>使用，<code>unique_lock</code>用于写入时加锁，<code>shared_lock</code>用于读取时加锁<br>对象在构造时自动对<code>std::shared_mutex</code>加锁，析构时自动解锁？</p>
<p><em>未完待续。。。</em></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量:"></a>信号量:</h3><p><code>semaphore(信号量)</code>用来进行线程同步<br>信号量一般包括2类：</p>
<ul>
<li><code>二元信号量(binary_semaphore)</code>：只有0&#x2F;1，实质上类似于互斥量的作用</li>
<li><code>计数信号量(counting_semaphore)</code>：正常情况下，用acquire来获取资源的访问权（计数器减），release用来释放资源（计数器加），当计数器为0时，线程阻塞</li>
</ul>
<h3 id="条件变量："><a href="#条件变量：" class="headerlink" title="条件变量："></a>条件变量：</h3><p><code>condition_variable</code>也是用来进行多线程同步的，当条件不满足时，线程阻塞；当满足条件时开始唤醒线程。条件变量利用全局变量共享的方式来达到线程同步的操作，主要如下两个动作：</p>
<ul>
<li>一个线程因等待条件满足而阻塞(<code>wait</code> &#x2F; <code>wait_for</code> &#x2F; <code>wait_until</code>)</li>
<li>一个线程完成操作，给出条件满足的信号(<code>notify_one</code> &#x2F; <code>notify_all</code>)，从而使其他线程被唤醒</li>
</ul>
<p>常规情况下，条件变量通常和一个互斥量std::mutex绑定</p>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once:"></a>call_once:</h3><p>call_once是在c++11引入的，作用是让某个操作只执行一次，即使在多线程操作下，也只执行一次</p>
<h3 id="线程操作相关："><a href="#线程操作相关：" class="headerlink" title="线程操作相关："></a>线程操作相关：</h3><ul>
<li><code>join</code>：阻塞主线程</li>
<li><code>detach</code>：不阻塞主线程，主线程和子线程的运行互不影响</li>
</ul>
<h3 id="异步编程："><a href="#异步编程：" class="headerlink" title="异步编程："></a>异步编程：</h3><p>异步编程的情况下，如果主线程需要使用子线程的计算结果，那么常用的方法是：<code>共享变量</code> &#x2F; <code>消息队列</code>，但操作和实现比较麻烦，所以C++11中引入了一个简单的异步接口工具<code>std::async</code><br><code>std::future类模版</code>用来关联线程运行的函数及其返回值，提供了访问异步操作结果的机制</p>
<ul>
<li><code>std::future</code>的三种状态：<ul>
<li>deferred：未启动</li>
<li>ready：已完成</li>
<li>timeout：超时</li>
</ul>
</li>
<li><code>std::future</code>结果的获取方式：<ul>
<li>get：等待异步结果并返回</li>
<li>wait：只等待结果，无返回值</li>
<li>wait_for：超时等待返回结果</li>
</ul>
</li>
</ul>
<h3 id="epoll-select"><a href="#epoll-select" class="headerlink" title="epoll&#x2F;select"></a>epoll&#x2F;select</h3><h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的6大原则："><a href="#设计模式的6大原则：" class="headerlink" title="设计模式的6大原则："></a>设计模式的6大原则：</h2><ul>
<li><code>单一职责原则</code>：就一个类而言，应该仅有一个引起它变化的原因。</li>
<li><code>开放封闭原则</code>：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li>
<li><code>里氏代换原则</code>：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li>
<li><code>依赖倒转原则</code>：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要针对实现编程。</li>
<li><code>迪米特原则</code>：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li>
<li><code>接口隔离原则</code>：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li>
</ul>
<h2 id="设计模式三大类："><a href="#设计模式三大类：" class="headerlink" title="设计模式三大类："></a>设计模式三大类：</h2><ul>
<li><code>创造型模式</code>：<code>单例模式</code>、<code>工厂模式</code>、建造者模式、原型模式</li>
<li><code>结构型模式</code>：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式</li>
<li><code>行为型模式</code>：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、<code>观察者模式</code>、状态模式、策略模式、模板方法模式、<code>访问者模式</code></li>
</ul>
<h2 id="几种常见的设计模式："><a href="#几种常见的设计模式：" class="headerlink" title="几种常见的设计模式："></a>几种常见的设计模式：</h2><p><code>单例模式</code>、<code>工厂模式</code>、<code>观察者模式</code></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式顾名思义就是只实例化一个对象，并为之提供唯一的全局访问入口</p>
<p><strong>主要的应用场景：</strong> 对于文件系统的操作，对于打印机的操作等，由于这些资源都是独一份的，所以正常情况下也就只单个对象单独访问，如果多个对象同时访问，则容易出现访问冲突的问题，所以单例模式就是为了解决这些场景问题诞生的</p>
<p><strong>常用的实现方式：</strong> 将默认构造函数、赋值构造函数、拷贝构造函数都声明成为私有函数，且将唯一全局访问入口声明成为静态函数，使用时直接用类名调用</p>
<ul>
<li><p><code>懒汉模式</code>：就是在首次使用的时候再初始化对象，这种方式有线程安全的问题，如果同时有多个线程去访问入口，则会实例化多个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Student *instance;</span><br><span class="line">    <span class="built_in">Student</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu) &#123;&#125;;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Student &amp;stu) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Student* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">        &#125;   <span class="comment">// 非线程安全</span></span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student* Student::instance instance;</span><br></pre></td></tr></table></figure>
<p>上述懒汉模式不是线程安全的，可以通过加锁的方式保证安全，但是加锁会影响运行速率，故而一般情况下推荐使用如下的饿汉模式</p>
</li>
<li><p><code>饿汉模式</code>：就是在类定义的时候就实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Student *instance;</span><br><span class="line">    <span class="built_in">Student</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu) &#123;&#125;;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Student &amp;stu) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Student* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student* Student::student instance = <span class="keyword">new</span> <span class="built_in">Student</span>(); <span class="comment">//静态成员变量的外部定义和初始化，参考static相关章节</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h3><p>工厂模式有3种：简单工厂模式、工厂方法模式、抽象工厂模式</p>
<h4 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h4><p>主要用于创建对象，工厂根据不同的输入产生不同的类，根据不同的虚函数的到不同的结果<br>主要适用在不同参数创建不同类的情况，比如计算器的+ - * &#x2F;，如下举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> Calculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> : <span class="keyword">public</span> Calculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Calculator *<span class="title">getCaculator</span><span class="params">(<span class="type">char</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arg) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Calculator *adder = Factor::<span class="built_in">getCaculator</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    adder-&gt;var1 = a;</span><br><span class="line">    adder-&gt;var2 = b;</span><br><span class="line">    </span><br><span class="line">    Calculator *suber = Factor::<span class="built_in">getCaculator</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    suber-&gt;var1 = a;</span><br><span class="line">    suber-&gt;var2 = b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add result: &quot;</span> &lt;&lt; adder-&gt;<span class="built_in">getResult</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add result: &quot;</span> &lt;&lt; suber-&gt;<span class="built_in">getResult</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><p>在简单工厂模式的基础上修正了不遵守开放修正原则，把选择和判断移到了客户端，如果想添加新功能，就只需要修改客户端即可，不用修改原来的类<br>主要应用场景：<br>待续。。。</p>
<h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><p>待续。。。</p>
<h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><p>是一种多个观察者和一个被观察者绑定的关系，实际上每个观察者里边都有一个被观察者的对象，而被观察者内部有所有观察者的对象，在被观察者状态发生变化的时候，就会通知所有观察者，观察者们就会做出相应的动作，说白了就是被观察者给观察者放风，学术化的讲就是当某个对象的变化需要引起其他对象的变化，且不知具体有哪些对象需要产生变化时，就可以用观察者模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;</span><br><span class="line"><span class="comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Subject *sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Observer</span>(string name, Subject *sub)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sub = sub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NBAObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NBAObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;Observer *&gt; observers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string action; <span class="comment">//被观察者对象的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Secretary</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*iter) == observer)</span><br><span class="line">            &#123;</span><br><span class="line">                observers.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StockObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NBAObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject *dwq = <span class="keyword">new</span> <span class="built_in">Secretary</span>();</span><br><span class="line">    Observer *xs = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;xiaoshuai&quot;</span>, dwq);</span><br><span class="line">    Observer *zy = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;zouyue&quot;</span>, dwq);</span><br><span class="line">    Observer *lm = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;limin&quot;</span>, dwq);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(xs);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(zy);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(lm);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;去吃饭了！&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;梁所长来了!&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="日常总结："><a href="#日常总结：" class="headerlink" title="日常总结："></a>日常总结：</h1><h2 id="指针大小："><a href="#指针大小：" class="headerlink" title="指针大小："></a>指针大小：</h2><p>在64位计算机中，指针类型大小为8字节</p>
<h2 id="解决哈希冲突的方法："><a href="#解决哈希冲突的方法：" class="headerlink" title="解决哈希冲突的方法："></a>解决哈希冲突的方法：</h2><h3 id="开放寻址法："><a href="#开放寻址法：" class="headerlink" title="开放寻址法："></a>开放寻址法：</h3><p>开放寻址的思路是，产生hash冲突的时候，给哈希的结果加上一个增量d，加了增量之后看下对应的空间有没有数据，如果没有就把数据放进去，根据增量序列产生的方式又分为3中小类：</p>
<ul>
<li>线性探测：朝着一个方向逐个探测</li>
<li>再平方探测：连个方向探测</li>
<li>随机探测：随机探测</li>
</ul>
<h3 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h3><p>所有冲突的元素组成一个链表</p>
<h3 id="溢出表："><a href="#溢出表：" class="headerlink" title="溢出表："></a>溢出表：</h3><p>一个哈希表分为2个部份，一部份是基表，一部分是溢出表，发生冲突的元素都放在溢出表中</p>
<h3 id="再哈希："><a href="#再哈希：" class="headerlink" title="再哈希："></a>再哈希：</h3><p>发生冲突后，利用比的hash方法再算一次，直到不冲突</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>UML（Unified Modeling Language）同一建模语言，是一种在面向对象开发系统中的建模语言，通常用来表示类之间的<code>依赖</code>、<code>关联</code>、<code>聚合</code>、<code>组合</code>、<code>泛化</code></p>
<h3 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h3><p>用来表示A类<code>use</code>了B，通常用<code>----&gt;</code>来表示，在C++中可以有如下的几种形式：</p>
<ol>
<li>A的成员函数返回了B的值</li>
<li>A的成员函数使用B类型作为参数</li>
<li>A的成员函数内部实现时使用了B<br><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_16.png" alt="UML-依赖"></li>
</ol>
<h3 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h3><p>通常理解为A<code>know</code>B，在C++中一般通过A类的成员变量是B的指针（引用&#x2F;值），一般有三种关联关系：<code>单向关联</code>、<code>双向关联</code>、<code>自身关联</code></p>
<h4 id="单项关联A-B："><a href="#单项关联A-B：" class="headerlink" title="单项关联A-&gt;B："></a>单项关联A-&gt;B：</h4><p>就是A知道B，但是B不知道A，A可以调用B的公共属性和方法，且没有生命周期的限制<br><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_12.png" alt="UML-单向关联"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB *pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向关联AB"><a href="#双向关联AB" class="headerlink" title="双向关联A&lt;-&gt;B:"></a>双向关联A&lt;-&gt;B:</h4><p>就是A和B互相知道对方，即可以互相调用对方的public方法和属性<br><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_14.png" alt="UML-双向关联"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassB *pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA *pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自身关联："><a href="#自身关联：" class="headerlink" title="自身关联："></a>自身关联：</h4><p>就是自己知道自己，这个在链表中是很常见的</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_10.png" alt="UML-自身关联"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassA *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合："><a href="#聚合：" class="headerlink" title="聚合："></a>聚合：</h3><p>聚合和组合都是用来表述整体-部分关系的<br>聚合是描述<code>has a</code>关系，类A中有类B，当类A的生命周期结束后类B仍然存在，比如桌子和房间的关系，当房间不在了，桌子时可以单独存在的</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_8.png" alt="UML-聚合"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Table table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h3><p>聚合和组合都是用来表述整体-部分关系的<br>聚合是描述<code>is part of</code>关系，类A中有类B，当类A的生命周期结束后类B也不存在，比如鸟和翅膀的关系，当鸟不在了，翅膀也不在了</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_6.png" alt="UML-组合"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wing</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wing leftWing;</span><br><span class="line">    Wing rightWing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️注意：从代码形式上看，聚合和组合是一样的，这个不同需要从语义分析的角度来区分</p>
<h3 id="泛化："><a href="#泛化：" class="headerlink" title="泛化："></a>泛化：</h3><p>泛化关系通常等价于类的继承关系，用来描述<code>is a</code>关系，比如警车也是个车<br><img src="http://www.cppblog.com/images/cppblog_com/lynch/Windows-Live-Writer/a3fe8013b5ff_13089/image_2.png" alt="UML-泛化"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">policeCar</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/tags/">Tags</a></li>
        
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">C++基础特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">变量及基本类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">指针和引用的区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">函数指针&#x2F;指针函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数指针：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">指针函数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88-%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">野指针&#x2F;悬空指针：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">const限定符：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cosnt%E5%92%8Cconsexpr"><span class="toc-number">1.5.</span> <span class="toc-text">cosnt和consexpr:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E7%9A%84%E8%AF%AD%E4%B9%89%E4%BA%8C%E4%B9%89%E6%80%A7%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">const的语义二义性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">define和const的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%92%8Ctypedef%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">define和typedef的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">this指针：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%92%8CC-%E5%AF%B9%E4%BA%8Estruct%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">C和C++对于struct的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct%E5%92%8Cunion%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">struct和union：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.12.</span> <span class="toc-text">typedef关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-malloc-calloc%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.13.</span> <span class="toc-text">new&#x2F;malloc&#x2F;calloc的区别和联系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.</span> <span class="toc-text">new和malloc的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E5%92%8Ccalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.2.</span> <span class="toc-text">malloc和calloc的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size-t%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">size_t：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%EF%BC%9A"><span class="toc-number">1.15.</span> <span class="toc-text">内联函数inline：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%EF%BC%9A"><span class="toc-number">1.16.</span> <span class="toc-text">volatile：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-C%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">1.17.</span> <span class="toc-text">extern C关键字：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="toc-number">1.18.</span> <span class="toc-text">strcpy的缺陷：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.19.</span> <span class="toc-text">自由存储区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%EF%BC%9A"><span class="toc-number">1.20.</span> <span class="toc-text">左值&#x2F;右值：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%EF%BC%9A-1"><span class="toc-number">1.20.1.</span> <span class="toc-text">左值&#x2F;右值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.20.2.</span> <span class="toc-text">左值引用&#x2F;右值引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.20.3.</span> <span class="toc-text">左值引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">1.21.</span> <span class="toc-text">右值引用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%9A"><span class="toc-number">1.22.1.</span> <span class="toc-text">移动构造和拷贝构造：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.23.</span> <span class="toc-text">move函数的实现原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">1.24.</span> <span class="toc-text">智能指针：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.24.1.</span> <span class="toc-text">智能指针的三个重要函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr%E6%AF%94unique-ptr%E5%B7%AE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9A"><span class="toc-number">1.24.2.</span> <span class="toc-text">auto_ptr比unique_ptr差的地方：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.24.3.</span> <span class="toc-text">unique_ptr:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#share-ptr%EF%BC%9A"><span class="toc-number">1.24.4.</span> <span class="toc-text">share_ptr：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.24.5.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-number">1.25.</span> <span class="toc-text">值传递、引用传递、指针传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.1.</span> <span class="toc-text">值传递：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.2.</span> <span class="toc-text">引用传递：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">1.25.3.</span> <span class="toc-text">指针传递：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.26.</span> <span class="toc-text">结构体相等的判断方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.</span> <span class="toc-text">强制类型转换：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.1.</span> <span class="toc-text">C语言中的强制类型转换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.27.2.</span> <span class="toc-text">C++中的强制类型转换：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-cast%EF%BC%9A"><span class="toc-number">1.27.2.1.</span> <span class="toc-text">static_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-cast%EF%BC%9A"><span class="toc-number">1.27.2.2.</span> <span class="toc-text">dynamic_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-cast%EF%BC%9A"><span class="toc-number">1.27.2.3.</span> <span class="toc-text">const_cast：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reinterpret-cast%EF%BC%9A"><span class="toc-number">1.27.2.4.</span> <span class="toc-text">reinterpret_cast：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.28.</span> <span class="toc-text">一些高级概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A8%A1%E7%89%88%EF%BC%89%EF%BC%9A"><span class="toc-number">1.28.1.</span> <span class="toc-text">泛型编程（模版）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.1.</span> <span class="toc-text">函数模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.2.</span> <span class="toc-text">类模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E7%89%88%EF%BC%9A"><span class="toc-number">1.28.1.3.</span> <span class="toc-text">变量模版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.1.4.</span> <span class="toc-text">函数重载和函数模版的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%92%8C%E7%B1%BB%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.1.5.</span> <span class="toc-text">函数模版和类模版的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%EF%BC%9A"><span class="toc-number">1.28.2.</span> <span class="toc-text">STL：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E7%9A%846%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.28.2.1.</span> <span class="toc-text">STL的6大组件：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.28.2.1.1.</span> <span class="toc-text">容器:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A6%82%E8%A6%81%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">1.28.2.1.1.1.</span> <span class="toc-text">容器的概要及使用原则：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.28.2.1.2.</span> <span class="toc-text">迭代器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.28.2.1.3.</span> <span class="toc-text">算法:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.28.2.1.4.</span> <span class="toc-text">仿函数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.28.2.1.5.</span> <span class="toc-text">适配器:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E4%BB%B6"><span class="toc-number">1.28.2.1.6.</span> <span class="toc-text">空间配置器件:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="toc-number">1.28.2.2.</span> <span class="toc-text">STL的缺陷：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E4%B8%ADreserve%E5%92%8Cresize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.28.2.3.</span> <span class="toc-text">vector中reserve和resize的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reserve%EF%BC%9A"><span class="toc-number">1.28.2.3.1.</span> <span class="toc-text">Reserve：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Resieze%EF%BC%9A"><span class="toc-number">1.28.2.3.2.</span> <span class="toc-text">Resieze：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%89%B9%E5%8C%96%EF%BC%9A"><span class="toc-number">1.28.2.4.</span> <span class="toc-text">模版特化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%EF%BC%9A"><span class="toc-number">1.28.2.5.</span> <span class="toc-text">类型萃取：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.29.</span> <span class="toc-text">C++ 11的新特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A"><span class="toc-number">1.29.1.</span> <span class="toc-text">auto类型推导：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A"><span class="toc-number">1.29.2.</span> <span class="toc-text">decltype类型推导：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.29.3.</span> <span class="toc-text">lambda表达式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.29.4.</span> <span class="toc-text">for语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.29.5.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0"><span class="toc-number">1.29.6.</span> <span class="toc-text">move函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.29.7.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E7%A6%81%E6%AD%A2%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.29.8.</span> <span class="toc-text">使用&#x2F;禁止对象的默认构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">1.29.9.</span> <span class="toc-text">constexpr:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%EF%BC%9A"><span class="toc-number">1.29.10.</span> <span class="toc-text">nullptr：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%9A"><span class="toc-number">1.29.11.</span> <span class="toc-text">可扩展的随机数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%8F%90%E4%BE%9B%E4%BA%86%E7%94%9F%E6%88%90%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8C%85%E5%90%AB2%E9%83%A8%E4%BB%BD%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E5%B8%83%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9A%84%E5%88%B0%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%85%88%E5%AE%9A%E4%B9%89%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E%EF%BC%8C%E5%B9%B6%E5%88%B6%E5%AE%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-number">1.30.</span> <span class="toc-text">C++11提供了生成伪随机数的新方法，生成随机数包含2部份：随机数引擎+随机数分布，也就是说如果想的到生成随机数的对象，必须先定义随机数引擎，并制定随机数的分布1234std::uniform_int_distribution&lt;int&gt; distribution(0, 99); &#x2F;&#x2F; 离散型均匀分布std::mt19937 engine; &#x2F;&#x2F; 随机数生成引擎auto generator &#x3D; std::bind(distribution, engine); &#x2F;&#x2F; 将随机数生成引擎和分布绑定生成函数int random &#x3D; generator();  &#x2F;&#x2F; 产生随机数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">C++的面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象的三大特征：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99-%E9%9A%90%E8%97%8F%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">函数的重载&#x2F;重写&#x2F;隐藏：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">多态的总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">虚函数和纯虚函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">虚继承：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">深拷贝&#x2F;浅拷贝：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">2.7.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.7.1.</span> <span class="toc-text">友元函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">2.7.2.</span> <span class="toc-text">友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.8.</span> <span class="toc-text">如何让一个类不能被继承：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-number">2.9.</span> <span class="toc-text">如何让类对象不能拷贝：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">2.10.</span> <span class="toc-text">如何让一个类不能实例化：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">2.11.</span> <span class="toc-text">拷贝构造为何必须声明为引用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.12.</span> <span class="toc-text">实例化一个类对象的步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">2.13.</span> <span class="toc-text">C++类对象的初始化顺序：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.14.</span> <span class="toc-text">如何禁止构造函数被使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.15.</span> <span class="toc-text">使用列表初始化快的原因：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9A"><span class="toc-number">2.16.</span> <span class="toc-text">静态绑定&#x2F;动态绑定：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-number">2.17.</span> <span class="toc-text">编译时多态&#x2F;运行时多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">2.17.1.</span> <span class="toc-text">编译时多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">2.17.2.</span> <span class="toc-text">运行时多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.17.3.</span> <span class="toc-text">两者的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="toc-number">2.18.</span> <span class="toc-text">如何让成员函数不可改变成员变量的值：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%A8%E6%A0%88-%E5%A0%86%EF%BC%9A"><span class="toc-number">2.19.</span> <span class="toc-text">限制对象内存在栈&#x2F;堆：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%A8%E6%A0%88%EF%BC%9A"><span class="toc-number">2.19.1.</span> <span class="toc-text">限制类对象的内存在栈：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%A8%E5%A0%86%EF%BC%9A"><span class="toc-number">2.19.2.</span> <span class="toc-text">限制类对象的内存在堆：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">进程间通信的方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">互斥量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">共享互斥量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">信号量:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">条件变量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-number">3.2.5.</span> <span class="toc-text">call_once:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">3.2.6.</span> <span class="toc-text">线程操作相关：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.2.7.</span> <span class="toc-text">异步编程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-select"><span class="toc-number">3.2.8.</span> <span class="toc-text">epoll&#x2F;select</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-number">3.3.</span> <span class="toc-text">I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%846%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">设计模式的6大原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E7%B1%BB%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">设计模式三大类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">几种常见的设计模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">工厂模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">简单工厂模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">工厂方法模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">抽象工厂模式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.3.</span> <span class="toc-text">观察者模式：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">日常总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">指针大小：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">解决哈希冲突的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">开放寻址法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">溢出表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%EF%BC%9A"><span class="toc-number">5.2.4.</span> <span class="toc-text">再哈希：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-number">5.3.</span> <span class="toc-text">UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">依赖：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">关联：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B9%E5%85%B3%E8%81%94A-B%EF%BC%9A"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">单项关联A-&gt;B：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94AB"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">双向关联A&lt;-&gt;B:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%BA%AB%E5%85%B3%E8%81%94%EF%BC%9A"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">自身关联：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%EF%BC%9A"><span class="toc-number">5.3.3.</span> <span class="toc-text">聚合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%EF%BC%9A"><span class="toc-number">5.3.4.</span> <span class="toc-text">组合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%EF%BC%9A"><span class="toc-number">5.3.5.</span> <span class="toc-text">泛化：</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/05/26/Note-C++/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/05/26/Note-C++/&text=C/C++基础知识"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/05/26/Note-C++/&is_video=false&description=C/C++基础知识"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C/C++基础知识&body=Check out this article: http://example.com/2024/05/26/Note-C++/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/05/26/Note-C++/&title=C/C++基础知识"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/05/26/Note-C++/&name=C/C++基础知识&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/05/26/Note-C++/&t=C/C++基础知识"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    XhZhang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
